// qwriter.c -*- C -*-
//
// This file is part of the c3p language compiler. This project
// is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License
//
// This project is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// If not, see <http://www.gnu.org/licenses/>.
//

/*
 *	ISO C99 Standard: Q writer implementation for symt
 */

#include "../../../include/qwriter.h"

#include "../../../include/assertb.h"
#include "../../../include/arrcopy.h"

FILE* qw_new(char *filename)
{
	assertp(filename != NULL, "filename must be defined");

	FILE * file = fopen(filename, "w");
	assertf(file != NULL, "internal IO error for %s", filename);

	return file;
}

void qw_prepare(FILE *obj)
{
	assertp(obj != NULL, "object must be defined");
	fprintf(obj, "// ---------------------------------\n");
	fprintf(obj, "// Q file generated by c3p compiler\n");
	fprintf(obj, "// ---------------------------------\n");
	fprintf(obj, "#include \"../../include/Qlib.h\"\n");
	fprintf(obj, "BEGIN");
	fprintf(obj, "\n/**************** Start static data ****************/\nSTAT(0)");
	fprintf(obj, "\n\tSTR(0x11ff6,\"%%d\");\t// For integer format at show");
	fprintf(obj, "\n\tSTR(0x11ff2,\"%%f\");\t// For double format at show");
	fprintf(obj, "\n\tSTR(0x11fee,\"%%c\");\t// For characer format at show");
	fprintf(obj, "\n\tSTR(0x11fea,\"%%s\");\t// For string format at show");
    fprintf(obj, "\n\tSTR(0x11fe6,\"%%d\\n\");\t// For integer format at show");
	fprintf(obj, "\n\tSTR(0x11fe2,\"%%f\\n\");\t// For double format at show");
	fprintf(obj, "\n\tSTR(0x11fde,\"%%c\\n\");\t// For characer format at show");
	fprintf(obj, "\n\tSTR(0x11fda,\"%%s\\n\");\t// For string format at show");
	fprintf(obj, "\n/**************** End static data ****************/");
	fprintf(obj, "\n/**************** Start code ****************/\nCODE(0)");
}

void qw_write_routine(FILE *obj, char *name, symt_label_t label, bool is_main, int q_direction)
{
	assertp(obj != NULL, "object must be defined");
	assertp(name != NULL, "name must be defined");

	if (is_main == true)
	{
		fprintf(obj, "\nL 0:\t/* Routine main */");
		fprintf(obj, "\n\tR7=0x%05x;\t// Store direction of main", q_direction);
		fprintf(obj, "\n\tR6=R7;\t// Move direction at R6");
	}
	else
		fprintf(obj, "\nL %d: /* Routine %s */", label, name);
}

void qw_write_close_routine(FILE *obj, char *name, bool is_main)
{
	assertp(obj != NULL, "object must be defined");
	assertp(name != NULL, "name must be defined");

	if (is_main != true)
	{
		fprintf(obj, "\n\tR6=R6-4;\t// Update R6 with previous call direction");
		fprintf(obj, "\n\tR0=I(R6);\t// Get the next label for last call");
		fprintf(obj, "\n\tGT(R0);\n/* End Routine %s */", name);
	}
}

void qw_write_close_routine_function(FILE *obj, char *name, int size)
{
	assertp(obj != NULL, "object must be defined");
	assertp(name != NULL, "name must be defined");

	fprintf(obj, "\n\tR6=R6+%d;\t// Update R6 with previous call direction", size);
	fprintf(obj, "\n\tR0=I(R6);\t// Get the next label for last call");
	fprintf(obj, "\n\tR6=R6-%d;", size);
	fprintf(obj, "\n\tGT(R0);\n/* End Routine %s */", name);
}

void qw_write_begin_loop(FILE *obj, symt_label_t label)
{
    assertp(obj != NULL, "object must be defined");
    fprintf(obj, "\nL %d:\n\tR7=R7-4;\t// Begin Loop", label);
}

void qw_write_end_loop(FILE *obj, symt_label_t label, symt_label_t next_label)
{
    assertp(obj != NULL, "object must be defined");
    fprintf(obj, "\n\tGT(%d);\t// Repeat loop\nL %d:\n\tR7=R7+4;\t// End Loop", label, next_label);
}

void qw_write_new_label(FILE *obj, symt_label_t label)
{
    assertp(obj != NULL, "object must be defined");
    fprintf(obj, "\nL %d:", label);
}

void qw_write_goto(FILE *obj, symt_label_t label)
{
    assertp(obj != NULL, "object must be defined");
    fprintf(obj, "\n\tGT(%d); // Execute break o continue", label);
}

void qw_write_call(FILE *obj, symt_label_t rout_label, symt_label_t label)
{
    assertp(obj != NULL, "object must be defined");

	fprintf(obj, "\n\tI(R6)=%d;\t// Store current label at memory", label);
	fprintf(obj, "\n\tR6=R6+4;\t// Update R6 for future calls");
	fprintf(obj, "\n\tGT(%d);\t// Jump to the call routine", rout_label);
	fprintf(obj, "\nL %d:", label);
}

void qw_write_call_return(FILE *obj, symt_label_t rout_label, symt_label_t label, int size, symt_cons_t type)
{
    assertp(obj != NULL, "object must be defined");

	fprintf(obj, "\n\tI(R6)=%d;\t// Store current label at memory", label);
	fprintf(obj, "\n\tR6=R6-%d;\t// Update R6 for future calls", size);

	if(size > 0)
	{
		switch(type)
		{
			case CONS_INTEGER: case CONS_BOOL: case CONS_CHAR:
				fprintf(obj, "\n\tI(R6)=%d;\t", 0);
			break;

			case CONS_DOUBLE:
				fprintf(obj, "\n\tD(R6)=%lf;\t", 0.0);
			break;
		}

		fprintf(obj, "\n\tR6=R6-4;\t");
	}

	fprintf(obj, "\n\tGT(%d);\t// Jump to the call routine", rout_label);

	switch(type)
	{
		case CONS_INTEGER: case CONS_BOOL: case CONS_CHAR:
			fprintf(obj, "\nL %d:\n\tR3=I(R6);", label);
		break;

		case CONS_DOUBLE:
			fprintf(obj, "\nL %d:\n\tRR3=D(R6);", label);
		break;

		//case CONS_STR: break;
	}
}

void qw_write_condition(FILE *obj, symt_label_t label)
{
    assertp(obj != NULL, "object must be defined");
	fprintf(obj, "\n\tIF(!R1) GT(%d);\t// Jump if condition is not true", label);
}

void qw_write_show(FILE *obj, symt_label_t label, symt_cons_t type, int q_direction, symt_value_t value, bool show_ln)
{
    assertp(obj != NULL, "object must be defined");
    switch(type)
    {
        case CONS_INTEGER: case CONS_BOOL:
            if(show_ln) fprintf(obj, "\n\tR1=0x11fe6;\t// Set integer format");
            else fprintf(obj, "\n\tR1=0x11ff6;\t// Set integer format with EOL");

            if(q_direction != 0) fprintf(obj, "\n\tR2=I(0x%05x);\t// Set value to print", q_direction);
            else fprintf(obj, "\n\tR2=%d;\t// Set value to print", *(int*)value);

            fprintf(obj, "\n\tR0=%d;\t// Set next label after print", label);
            fprintf(obj, "\n\tGT(putf_int_);\t// Execute print");
            fprintf(obj, "\nL %d:\t", label++);
		break;

        case CONS_CHAR:
            if(show_ln) fprintf(obj, "\n\tR1=0x11fde;\t// Set char format");
            else fprintf(obj, "\n\tR1=0x11fee;\t// Set char format with EOL");

            if(q_direction != 0) fprintf(obj, "\n\tR2=I(0x%05x);\t// Set value to print", q_direction);
            else fprintf(obj, "\n\tR2=%d;\t// Set value to print", *(char*)value);

            fprintf(obj, "\n\tR0=%d;\t// Set next label after print", label);
            fprintf(obj, "\n\tGT(putf_int_);\t// Execute print");
            fprintf(obj, "\nL %d:\t", label++);
        break;

		case CONS_DOUBLE:
            if(show_ln) fprintf(obj, "\n\tR1=0x11fe22;\t// Set double format");
            else fprintf(obj, "\n\tR1=0x11ff2;\t// Set double format with EOL");

            if(q_direction != 0) fprintf(obj, "\n\tRR1=D(0x%05x);\t// Set value to print", q_direction);
            else fprintf(obj, "\n\tRR1=%f;\t// Set value to print", *(double*)value);

            fprintf(obj, "\n\tR0=%d;\t// Set next label after print", label);
            fprintf(obj, "\n\tGT(putf_double_);\t// Execute print");
            fprintf(obj, "\nL %d:\t", label++);
		break;
    }
}

int qw_write_array(FILE *obj, symt_cons_t type, int q_direction, size_t array_length, size_t section_label)
{
	assertp(obj != NULL, "object must be defined");
	size_t incr_mem = type != CONS_DOUBLE? 4 : 8;
	size_t mem_array = incr_mem * array_length;

	fprintf(obj, "\nSTAT(%d)", (int)section_label);
	fprintf(obj, "\n\tFIL(0x%05x, %d, 0);\t// Reserve memory for array", q_direction, (int)mem_array);
	fprintf(obj, "\nCODE(%d)", (int)section_label);

	return q_direction - mem_array;
}

void qw_write_reg_to_array(FILE *obj, int num_reg, symt_cons_t type, int ini_q_direction, size_t pos)
{
	assertp(obj != NULL, "object must be defined");
	size_t incr_mem = type != CONS_DOUBLE? 4 : 8;
	size_t mem_array = ini_q_direction - (incr_mem * pos);

	qw_write_reg_to_var(obj, num_reg, type, mem_array);
}

void qw_write_value_to_var(FILE *obj, symt_cons_t type, int q_direction, symt_value_t value)
{
	assertp(obj != NULL, "object must be defined");

	int value_int;
	double value_double;

	switch(type)
	{
		case CONS_INTEGER: case CONS_BOOL: case CONS_CHAR:
			value_int = *(int*)value;
			fprintf(obj, "\n\tI(0x%05x)=%d;\t// Store value to variable", q_direction, value_int);
		break;

		case CONS_DOUBLE:
			value_double = *(double*)value;
			fprintf(obj, "\n\tD(0x%05x)=%lf;\t// Store value to variable", q_direction, value_double);
		break;

		//case CONS_STR: break;
	}
}

void qw_write_var_to_reg(FILE *obj, symt_label_t num_reg, symt_cons_t type, int q_direction)
{
	assertp(obj != NULL, "object must be defined");

	int value_int;
	double value_double;

	switch(type)
	{
		case CONS_INTEGER: case CONS_BOOL: case CONS_CHAR:
			assertf(num_reg >= 0 && num_reg <= 7, "%d is not a valid register", num_reg);
			fprintf(obj, "\n\tR%d=I(0x%05x);\t// Load variable to register", num_reg, q_direction);
		break;

		case CONS_DOUBLE:
			assertf(num_reg >= 0 && num_reg <= 4, "%d is not a valid register", num_reg);
			fprintf(obj, "\n\tRR%d=D(0x%05x);\t// Load variable to register", num_reg, q_direction);
		break;

		//case CONS_STR: break;
	}
}

void qw_write_value_to_reg(FILE *obj, int num_reg, symt_cons_t type, symt_value_t value)
{
	assertp(obj != NULL, "object must be defined");

	int value_int;
	double value_double;

	switch(type)
	{
		case CONS_INTEGER: case CONS_BOOL: case CONS_CHAR:
			value_int = *(int*)value;
			assertf(num_reg >= 0 && num_reg <= 7, "%d is not a valid register", num_reg);
			fprintf(obj, "\n\tR%d=%d;\t// Set value to register", num_reg, value_int);
		break;

		case CONS_DOUBLE:
			value_double = *(double*)value;
			assertf(num_reg >= 0 && num_reg <= 4, "%d is not a valid register", num_reg);
			fprintf(obj, "\n\tRR%d=%f;\t// Set value to register", num_reg, value_double);
		break;

		//case CONS_STR: break;
	}
}

void qw_write_reg_to_var(FILE *obj, int num_reg, symt_cons_t type, int q_direction)
{
	assertp(obj != NULL, "object must be defined");

	switch(type)
	{
		case CONS_INTEGER: case CONS_BOOL: case CONS_CHAR:
			fprintf(obj, "\n\tI(0x%05x)=R%d;\t// Store result register at variable", q_direction, num_reg);
		break;

		case CONS_DOUBLE:
			fprintf(obj, "\n\tD(0x%05x)=RR%d;\t// Store result register at variable", q_direction, num_reg);
		break;

		//case CONS_STR: break;
	}
}

void qw_write_expr(FILE *obj, qw_op_t sign, symt_cons_t type, symt_label_t label, int num_reg_1, int num_reg_2)
{
	assertp(obj != NULL, "object must be defined");

	if (type == CONS_INTEGER || type == CONS_BOOL || type == CONS_CHAR)
	{
		switch(sign)
		{
			// Comparison
			case QW_LESS: fprintf(obj, "\n\tR%d=R%d<R%d;\t// Less operation", 1, num_reg_1, num_reg_2); 					break;
			case QW_GREATER: fprintf(obj, "\n\tR%d=R%d>R%d;\t// Greater operation", 1, num_reg_1, num_reg_2); 				break;
			case QW_LESS_THAN: fprintf(obj, "\n\tR%d=R%d<=R%d;\t// Less than operation", 1, num_reg_1, num_reg_2); 			break;
			case QW_GREATER_THAN: fprintf(obj, "\n\tR%d=R%d>=R%d;\t// Greater than operation", 1, num_reg_1, num_reg_2);    break;
			case QW_EQUAL: fprintf(obj, "\n\tR%d=R%d==R%d;\t// Equal operation", 1, num_reg_1, num_reg_2); 					break;
			case QW_NOT_EQUAL: fprintf(obj, "\n\tR%d=R%d!=R%d;\t// Not equal operation", 1, num_reg_1, num_reg_2); 			break;

			// Logical
			case QW_AND: fprintf(obj, "\n\tR%d=R%d&&R%d;\t// And operation", 1, num_reg_1, num_reg_2); 						break;
			case QW_OR: fprintf(obj, "\n\tR%d=R%d||R%d;\t// Or operation", 1, num_reg_1, num_reg_2); 						break;
			case QW_NOT: fprintf(obj, "\n\tR%d=!R%d;\t// Not operation", 1, num_reg_1); 									break;

			// Arithmetic
			case QW_ADD: fprintf(obj, "\n\tR%d=R%d+R%d;\t// Add operation", 1, num_reg_1, num_reg_2); 						break;
			case QW_SUB: fprintf(obj, "\n\tR%d=R%d-R%d;\t// Sub operation", 1, num_reg_1, num_reg_2); 						break;
			case QW_MULT: fprintf(obj, "\n\tR%d=R%d*R%d;\t// Mult operation", 1, num_reg_1, num_reg_2); 					break;
			case QW_DIV: fprintf(obj, "\n\tR%d=R%d/R%d;\t// Div operation", 1, num_reg_1, num_reg_2); 						break;
			case QW_POW: case QW_MOD:
				fprintf(obj, "\n\tR0=%d;\t// Set return label", label);
				fprintf(obj, "\n\tR3=%d;\t// Set operation for integers", 0);
				if (sign == QW_POW) fprintf(obj, "\n\tGT(pow_);\t// Pow operation");
				else fprintf(obj, "\n\tGT(mod_);\t// Mod operation");
				fprintf(obj, "\nL %d:", label);
			break;
		}
	}
	else if (type == CONS_DOUBLE)
	{
		switch(sign)
		{
			// Comparison
			case QW_LESS: fprintf(obj, "\n\tR%d=RR%d<RR%d;\t// Less operation", 1, num_reg_1, num_reg_2); 					break;
			case QW_GREATER: fprintf(obj, "\n\tR%d=RR%d>RR%d;\t// Greater operation", 1, num_reg_1, num_reg_2); 			break;
			case QW_LESS_THAN: fprintf(obj, "\n\tR%d=RR%d<=RR%d;\t// Less than operation", 1, num_reg_1, num_reg_2); 		break;
			case QW_GREATER_THAN: fprintf(obj, "\n\tR%d=RR%d>=RR%d;\t// Greater than operation", 1, num_reg_1, num_reg_2);  break;
			case QW_EQUAL: fprintf(obj, "\n\tR%d=RR%d==RR%d;\t// Equal operation", 1, num_reg_1, num_reg_2); 				break;
			case QW_NOT_EQUAL: fprintf(obj, "\n\tR%d=RR%d!=RR%d;\t// Not equal operation", 1, num_reg_1, num_reg_2); 		break;

			// Logical
			case QW_AND: fprintf(obj, "\n\tR%d=RR%d&&R%d;\t// And operation", 1, num_reg_1, num_reg_2); 					break;
			case QW_OR: fprintf(obj, "\n\tR%d=RR%d||RR%d;\t// Or operation", 1, num_reg_1, num_reg_2); 						break;
			case QW_NOT: fprintf(obj, "\n\tR%d=!RR%d;\t// Not operation", 1, num_reg_1); 									break;

			// Arithmetic
			case QW_ADD: fprintf(obj, "\n\tRR%d=RR%d+RR%d;\t// Add operation", 1, num_reg_1, num_reg_2); 					break;
			case QW_SUB: fprintf(obj, "\n\tRR%d=RR%d-RR%d;\t// Sub operation", 1, num_reg_1, num_reg_2); 					break;
			case QW_MULT: fprintf(obj, "\n\tRR%d=RR%d*RR%d;\t// Mult operation", 1, num_reg_1, num_reg_2); 					break;
			case QW_DIV: fprintf(obj, "\n\tRR%d=RR%d/RR%d;\t// Div operation", 1, num_reg_1, num_reg_2); 					break;
			case QW_POW: case QW_MOD:
				fprintf(obj, "\n\tR0=%d;\t// Set return label", label);
				fprintf(obj, "\n\tR3=%d;\t// Set operation for integers", 1);
				if (sign == QW_POW) fprintf(obj, "\n\tGT(pow_);\t// Pow operation");
				else fprintf(obj, "\n\tGT(mod_);\t// Mod operation");
				fprintf(obj, "\nL %d:", label);
			break;
		}
	}
}

void qw_close(FILE * obj, symt_label_t label)
{
	assertp(obj != NULL, "object must be defined");
	fprintf(obj, "\nL %d:", label);
	fprintf(obj, "\n\tGT(-2);\t/* Exit program without errors */");
	fprintf(obj, "\n/**************** End code ****************/\nEND");
	fclose(obj);
}
