\subsection{Expresiones de Sentencia}

En \textbf{c3P} cada expresión, sentencia o declaración que se codifique se escribe en una sola
línea, por lo que no se pueden representar más de una declaración en una línea. Esto
no afecta a las condiciones y expresiones aritmético/lógicas, pero sí a las estructuras
de control, declaración de funciones y procedimientos, variables, etc. A continuación,
se muestra ejemplos válidos e inválidos de declaraciones.

\begin{verbatim}

? Declaración de expresiones correcta
x : i32 = 10
y : i32 = 20
z : i32 = x + y
z = z + x * 2 / 10
call show "z = " + call str z

? Declaración de expresiones incorrecta
if (x == y) if (y != 10)

endif endif

? Incorrecto
x : i32 = 10, y = 10
\end{verbatim}

\subsection{Sentencia if}

En \textbf{c3P} se puede utilizar la sentencia «if» para controlar el flujo del programa mediante una operación condicional.

\begin{verbatim}
if (test)
  codigo1
else
  codigo2
endif
\end{verbatim}

Si «test» se evalúa como verdadera, entonces se ejecutará «codigo1» mientras que «codigo2» no lo hará. Si el resultado de la prueba es falso, tendrá lugar el efecto contrario «codigo2» se ejecutará mientras «codigo1» no lo hará. La cláusula «else» es opcional. 

Es posible emplear varias sentencias «if» para comprobar múltiples condiciones, como se muestra en el ejemplo:

\begin{verbatim}
if (x == 1)
  call show  ("x es 1")
else if (x == 2)
  call show  ("x es 2")
else if (x == 3)
  call show  ("x es 3")
else
  call show  ("x es otra cosa")
endif
\end{verbatim}

\subsection{Sentencia switch}

En \textbf{c3P} se puede utilizar la sentencia «switch» para controlar el flujo de un programa.

\begin{verbatim}
switch (test)
    caso1:
      si igual a caso1...
    caso2:
      si igual a caso2...
    ...
    def:
      declaración por defecto
endswitch
\end{verbatim}

La sentencia «switch» compara «test» con cada uno de los casos, hasta encontrar un que sea igual a test. Entonces, se ejecutan las sentencias que siguen al caso exitoso.

\begin{verbatim}
switch (x)
    0:
      call show "x es 0"
      break
    1:
      call show "x es 1"
      break
    def:
      call show "x es otro valor"
      break
endswitch
\end{verbatim}

Hay que tener en cuenta que el uso de la sentencia break es importante
declararlo en cada caso del switch, porque puede que se ejecuten de
forma equivocada el resto de casos siguientes.

\subsection{Sentencia while}
La declaración «while» es un bucle en el que en cada iteración se comprueba una condición,
que si se satisface, se repite la ejecución del bucle hasta que no se cumpla el criterio
de parada. A continuación se muestra un ejemplo:

\begin{verbatim}
counter : i32 = 0

while (counter < 10)
  call show str(counter)
  counter = counter + 1
endwhile
\end{verbatim}

\subsection{Sentencia for}
El bucle con la declaración «for» es similar al «while», pero con la característica de que
inicializa una variable, que en cada iteración varía, hasta que se cumpla una condición.
La codificación del bucle se hace primero inicializando la variable, luego estableciendo
la condición de parada, y después indicando la expresión que se va a ejecutar para cambiar
la variable tras la iteración. Cada parte del «for» está separado por comas, encerrado en
paréntesis, y el cuerpo del bucle termina en «endfor».

\begin{verbatim}
for (x : i32 = 0, x < 10, x = x + 1)
  call show (call str x)
endfor
\end{verbatim}

\subsection{Sentencia readonly}

La sentencia readonly establece que una vez se le asigne un valor a una variable este valor nunca podrá ser modificado. En el caso de asignar un valor a una variable esta tomará por defecto 0.

\begin{verbatim}
readonly x : i32 = 5
readonly y : i32 = 10
\end{verbatim}

\subsection{Sentencia hide}

El acceso privado se puede declarar en \textbf{c3P} en funciones, procedimientos,
o variables globales (fuera de funciones/procedimientos), pero nunca en variables
locales. Con este modificador de acceso, las componentes que lo tengan no podrán
ser accesibles al importar el fichero desde otro fichero fuente

\begin{verbatim}
hide x : i32 = 1

hide func y(x : i32)
    ret x * 2
endfunc

proc show_x()
    call showln (call str x)
endproc
\end{verbatim}

\subsection{Bloques}
\subsubsection{Sentencia break}

La declaración break se utiliza para terminar la ejecución de un bucle
o de una estructura tipo switch. Cabe destacar que esta sentencia afecta
al bucle o switch más interno en el que esté dentro.
A continuación se muestra un ejemplO:

\begin{verbatim}
for (x : i32 = 1, x <= 10, x = x + 1)
    if (x == 8)
      break
    else
      call show (call str x)
    endif
endfor
\end{verbatim}

Si pone una sentencia «break» dentro de un bucle o sentencia switch» que a su vez está dentro de un bucle o sentencia «switch»,
el «break» sólo termina el bucle o sentencia «switch» más interno. 

\subsubsection{Sentencia continue}

La declaración continue permite terminar la iteración actual del bucle y
comenzar la siguiente sin salir de él. Hay que tener en cuenta que esta
declaración sólo afecta al bucle más interno en el que esté dentro.

\begin{verbatim}
suma : i32 = 0

for (x : i32 = 0, x < 100, x++)
    if (x % 2 == 0)
      continue
    else
      suma = suma + x
    endif
endfor
\end{verbatim}

Si pones una sentencia «continue» dentro de un bucle que a su vez está dentro de un bucle, entonces sólo afecta al bucle más interno. 

\subsubsection{Sentencia ret}

La sentencia ret se utiliza para indicar el valor que va a devolver una función al
terminar su ejecución. En \textbf{c3P}, siempre se tiene que devolver en una
función un valor, pero jamás se puede usar en un procedimiento.

\begin{verbatim}
func cumsum : i32(x : i32[])
    value : i32 = 0
    
    for (i : i32 = 0, i < x.L, i = i + 1)
        value = value + x[i]
    endfor
    
    ret value
endfunc
\end{verbatim}