\subsection{Tipos de Datos Primitivos}
\subsubsection{Tipos Enteros}

En \textbf{c3P}, los tipos enteros se diferencian no sólo por su identificador (nombre del
tipo de entero), sino también por el rango de valores que pueden almacenar, que se miden
por bits y pueden alcanzar los 64 bits.

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|}
         \hline
         \textbf{Identificador} & \textbf{NºBits} & \textbf{Rango} \\
         \hline
         i8 & 8 & -128 a 127 \\
         \hline
         i16 & 16 & -32768 a 32767 \\
         \hline
         i32 & 32 & -214483648 a 2147483647 \\
         \hline
         i64 & 64 & -9223372036854775808 a 9223372036854775807 \\
         \hline
    \end{tabular}
    \caption{Tipos Enteros}
    \label{tab:tab_tipos_enteros}
\end{table}

\subsubsection{Tipos de Números Reales}

Al igual que los números enteros, los tipos de números reales se diferencian tanto
por su identificador, sino también por su rango de valores que pueden almacenar,
que pueden alcanzar hasta los 64 bits.

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|}
         \hline
         \textbf{Identificador} & \textbf{NºBits} & \textbf{Rango} \\
         \hline
         f32 & 32 & -3.4e37 a 3.4e38 \\
         \hline
         f64 & 64 & -1.7e308 a 1.7e308 \\
         \hline
    \end{tabular}
    \caption{Tipos Enteros}
    \label{tab:tab_tipos_decimales}
\end{table}

\subsubsection{Tipos de Carácter}

Los tipos de caracteres permiten representar uno o varios caracteres de dígitos,
letras, u otros símbolos, a excepción de los caracteres especiales.

\begin{itemize}
    \item \textbf{c}: puede contener un valor que cumple '([a-zA-Z0-9\+\-\_\&\%...]+)*'
\end{itemize}

\subsubsection{Tipos Lógicos}

Los tipos de datos lógicos se codifican mediante el identificador «b», y pueden tomar dos
valores posibles (verdadero codificado en «T», o falso representado en «F»).

\subsection{Contenedores}

Un \textbf{contenedor} es una estructura de datos en la que se almacena valores de un
mismo tipo. Estos elementos están organizados internamente a partir de los índices del
contenedor, que marcan cada una de los posiciones en las que se almacena su contenido.

En \textbf{c3P}, los contenedores son de tamaño fijo y permiten operaciones de indexación.
Actualmente, el compilador no genera correctamente ficheros objetos en los que se usen
contenedores como parámetros, aunque dentro de la sintaxis sí que se admite.

\subsubsection{Declaración de contenedores}

Un contenedor se declara especificando el tipo de datos que tendrá cada elemento,
el nombre de la variable, y el número de elementos que puede almacenar, tal y como
se puede observar en el siguiente ejemplo:

\begin{verbatim}
mi_array : i32[10]
\end{verbatim}

Respecto al tamaño de un contenedor, puede declararse sólo con una constante literal
entera positiva, lo que significa que no existen contenedores dependientes de los
valores de variables locales, globales, o parámetros.

\subsubsection{Inicialización de contenedores}

Los elementos de un contenedor se pueden inicializar de forma individual por medio de
la indexación, o también a partir de la declaración entre llaves de valores literales,
donde cada elemento tendrá asociado la posición en la que se define. En este ejemplo
se puede observar la segunda inicialización explicada:

\begin{verbatim}
mi_array : i32[5] = { 0, 1, 2, 3, 4 }
\end{verbatim}

Un contenedor se puede inicializar en su declaración con sólo la especificación de algunos
de sus elementos. Esto significa que los elementos no definidos se asignarán con su valor
por defecto. Ahora bien, si se quiere inicializar posiciones no contiguas, es necesario
definir con su valor por defecto los elementos que los separa. A continuación se muestran
algunos ejemplos con estos casos:

\begin{verbatim}
	mi_array_1 : i32[5] = { 2, 3, 4 }	? mi_array_1 = { 2, 3, 4, 0, 0 }
	mi_array_2 : i32[5] = { 2 }		? mi_array_2 = { 2, 0, 0, 0, 0 }
	mi_array_3 : i32[5] = { 0, 0, 3 }	? mi_array_3 = { 0, 0, 3, 0, 0 }
\end{verbatim}

\subsubsection{Acceso a los elementos de un Contenedor}

En \textbf{c3P}, los elementos de un contenedor se pueden acceder por medio de su índice y
con la operación de indexación. Para ello, se especifica el nombre del contenedor, seguido
del índice del elemento al que se quiere acceder, encerrado entre corchetes. A continuación
se muestra un ejemplo de esta funcionalidad:

\begin{verbatim}
mi_array[0] = 5
\end{verbatim}

Cabe mencionar que, los índices pueden ser cualquier expresión compleja excepto las llamadas
a funciones. En casos en los que se quiera utilizar como índice el resultado de una llamada,
es necesario que primero se guarde el retorno en una variable para luego usarla como índice
en la operación de indexación del contenedor.

\subsection{Tamaño de Contenedores}

En \textbf{c3P}, para obtener el tamaño de un contenedor existe la función «arrlen»,
que devuelve un número entero que puede almacenarse como i8, i16, i32, o i64. En
este ejemplo se muestra un caso de uso de esta función.

\begin{verbatim}
mi_array : i32[3] = {0, 1, 2}
x : i32 = call arrlen mi_array
\end{verbatim}
